Perfect 8-Point Answer on async/await

async and await are keywords in JavaScript used to handle asynchronous operations more readably compared to .then() and .catch().

An async function always returns a Promise. Even if you return a normal value, it is wrapped inside a resolved Promise.

async is placed before a function declaration/expression. Inside that function, await is used before a Promise to pause its execution until the Promise settles (resolves or rejects).

await can only be used inside an async function (except for top-level await in ES modules, supported in modern JavaScript).

Behind the scenes:

JavaScript is single-threaded and uses an event loop and microtask queue for async tasks.

When await is encountered, the async function execution suspends and the rest of the program continues.

Once the Promise resolves, the function resumes where it left off from the microtask queue without blocking the main thread.

Error handling is simpler with try...catch inside async/await compared to .catch() in traditional Promises.

For parallel execution: If multiple async tasks are independent, Promise.all() can be used with await to avoid unnecessary sequential waiting.

const [user, posts] = await Promise.all([fetchUser(), fetchPosts()]);


async/await is syntactic sugar over Promises — under the hood, it still uses Promises and doesn’t replace them.

#CallBack

Here’s the perfect 5–6 point version you can use directly in interviews:

Definition: A callback is a function passed as an argument to another function, executed later when a task completes.

Usage: Commonly used for asynchronous operations like API calls, reading files, event handling, etc.

Benefit: Enables non-blocking code execution, improving performance.

Callback Hell: Excessive nesting of callbacks creates the “pyramid of doom,” making code hard to read and maintain.

Inversion of Control: We rely on external code to invoke our callbacks correctly; misuse can cause bugs.

Modern Solution: Promises and async/await were introduced to address callback hell and improve flow control and error handling.


const k = fetch(api);
console.log(k) we get output in console,it will return a promise object in pending state because JavaScript not wait for fullfilled the promised that why its show pending state as soon as promised resolve or reject after certain time its show promised state as fullfilled,promisedresult replace undefined by respone which readstream form that we can convert into the json format as we required for that we have to use then()method on k

def: promise is an object which reperesting eventual complition or failure of an asynchronous operations

we are attaching the handlers to the promised object which create inside the function

Promises Apis
Promise.all([p1,p2,p3])
the promise.all api helps to fullfilled the multiple promises parally,in that it will wait for all promise must be fullfilled then get the result otherwise no ,one another curcial point is any of the promises get rejected or fail ,it will immediatley through an error

Promise.allSettled
the promise.allSettled api which is used resolve multimple promises parally,in that we get result when all the promises fullfilled,if any promises get an error,It will not throw an error,It will take time all the promises should be settled whether is resolve or rejected after that we get result as we required according to promisedresult

Promise.race([])
in this promise api we are get result when very fisrt promised which is fullfilled or resolve whether is resolve or rejected ,it will not wait for rest of the promised settle or fullfilled

Promise.any
in this promise api we are get result when only very first success promise will get resolve,in that case if promised get fail then it will be ignore
and another important point is if all the promises will get error or rejected then it will throw aggregateError

this
1.this keyword used in the gloabal space it will return if we console.log window object 
this keyword which in gloabal space which has always value of global space
gloabal object different for different cicumstances

2.what is the value of this in gloabal space
the gloabal object it can different based on where we runing JavaScript the code

3.this keyword work differently whether we used strict mode and non strict mode
if we used this keyword in function space ,
the value depends on the strict mode and non strict mode and how the function is invoke and called
'strict mode'
function x(){
    console.log(this)
}
x()without referance undefined
window.x() with referance window object
without using strict mode the value of this keyword is window object,with using strict mode it works differently the value of this keyword is undefined
this inside non strict mode - this subsitiuation

4.if we are writting function inside the object that function know one of the method we can say

for Example :
   const obj = {
    a:10,
    x:function(){
        console.log(this);
    }
   }
   obj.x()
in this above example x is method obj object.
what is the value of this if we calling obj.x() the value is object {a:10,x:f}
   
     const obj = {
    a:10,
    x:function(){
        console.log(this.a);//the result in the console is 10 why because the value of this keyword is object and object have 'a' property
    }
   }
   obj.x()

   4.arrow function don't provide  their own this keyword binding (it return this value of the enclosing the lexical context)

   5.if we used this keyword in html dom what will be the value of this keyword
   <button onclick="alert(this)">click me</button> 
   the value of this keyword referance of the html element
   

   # call,apply,bind

1.Definition:
The call() method in JavaScript is used to borrow a function from one object and invoke it with another object as this.
               OR   
1. call method is used to call the function with the given this value and argument can be passed individually.
          
2.Syntax:

func.call(thisArg, arg1, arg2, ...);

thisArg → the object you want to use as this.

arg1, arg2... → arguments passed individually.

3.For Example
const person1 = {
  name: "Gopal",
  greet: function (message) {
    console.log(`${message}, ${this.name}`);
  }
};

const person2 = { name: "Chavan" };

// Borrow greet from person1 and use it with person2
person1.greet.call(person2, "Hello"); 

# apply
Definition:
apply() is just like call(), but instead of passing arguments individually, you pass them as an array.

Syntax:

func.apply(thisArg, [argsArray]);

Example with apply()
function greet(message, punctuation) {
  console.log(`${message}, ${this.name}${punctuation}`);
}

const person1 = { name: "Gopal" };
const person2 = { name: "Chavan" };

// Using apply (arguments as array)
greet.apply(person1, ["Hello", "!"]);   // Hello, Gopal!
greet.apply(person2, ["Hi", "!!"]); 

#bind
bind method is similar to call method. It is also used to override this value, but the difference is it will not invoke the function instantly but return a function with attached this and argument which can be called later.

const greetPerson1 = greet.bind(person1, "Hello");
const greetPerson2 = greet.bind(person2, "Hi");

greetPerson1(); // Hello, Gopal
greetPerson2(); // Hi, Chavan


1. call method is used to call the function with the given this value and argument can be passed individually.
2. apply method is similar to call method, the only difference is that instead of passing argument individually, will pass the argument in a list/array.
3. bind method is similar to call method. It is also used to override this value, but the difference is it will not invoke the function instantly but return a function with attached this and argument which can be called later.
